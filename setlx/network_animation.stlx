//member variablen

//drawOutputLayer
drawOutputLayer := procedure(mNetwork, x, y, r, text) {	
	for(i in {0 .. mNetwork[#mNetwork]-1}) {
		gfx_setPenColorRGB( 0.0, 0.0, 0.0 );
		
		gfx_filledCircle(x, ((940-3*r*mNetwork[#mNetwork])/2)+3*r*i, r);
		gfx_textLeft(x+30, ((940-3*r*mNetwork[#mNetwork])/2)+3*r*i, i + ": " + text[i+1]);
	}	
};

//drawNeuron
//data = test_data, weights = weights, dataFlag = true|false, weightFlag = true|false, x-axis, y-axis, a, b, pixelSize
drawNeuron := procedure(data, weights, dataFlag, weightsFlag, x, y, disX, disY, a, b, pixelSize) {
	color := 0.0;
	hadamardFlag := false;
	for(i in {1 .. 28}) {
		for(j in {1 .. 28}) {
			if(!dataFlag && !weightsFlag) {						// dataFlag == false && weightFlag == false; print init
				color := 0.0;
			} else if(dataFlag && !weightsFlag) {					// dataFlag == true && weightFlag == false; print values
				color := 1.0 - data[a][b][(784-(28*i)+j)];
			} else if(!dataFlag && weightsFlag) {					// dataFlag == false && weightFlag == true; print weights
				color := weights[1][b][(784-(28*i)+j)];
			} else if(dataFlag && weightsFlag) {					// dataFlag == true && weightFlag == true; print hadamard
				if(data[1][b][(784-(28*i)+j)] == 0.0 || data[1][b][(784-(28*i)+j)] == -0.0) {
					color := weights[1][b][(784-(28*i)+j)];
					hadamardFlag := false;
				} else {
					color := data[1][b][(784-(28*i)+j)];
					hadamardFlag := true;
				}
			}
			
			if(!dataFlag && !weightsFlag) {
				gfx_setPenColorRGB( color, color, color );
			} else if( color == 0.0 || color == -0.0 ) {
				gfx_setPenColorRGB( 1.0, 1.0, 1.0 );
			} else if(dataFlag && weightsFlag && !hadamardFlag) {
				if( color < 0.0 ) {
					// negativ values | green
					// color * RGB(0,255,0) + RGB(255,255,255)
					color *= -1.0;
					gfx_setPenColorRGB( color, color+(1.0-color), color );
				} else {	
					// positiv values | yellow
					// color * RGB(255,255,0) + RGB(255,255,255)
					gfx_setPenColorRGB( color+(1.0-color), color+(1.0-color), color );
				}
			} else {
				if( color < 0.0 ) {
					// negativ values | blue
					// color * RGB(0,0,255) + RGB(255,255,255)
					color *= -1.0;
					gfx_setPenColorRGB( color, color, color+(1.0-color) );
				} else {	
					// positiv values | red
					// color * RGB(255,0,0) + RGB(255,255,255)
					gfx_setPenColorRGB( color+(1.0-color), color, color );
				}
			}
			
			if(dataFlag && !weightsFlag) {
				gfx_filledRectangle( x+pixelSize*j+disX, y+pixelSize*i+disY, pixelSize/3, pixelSize/3 ); 
			} else {
				gfx_filledRectangle( x+pixelSize*j+disX, y+pixelSize*i+(a-1)*28*pixelSize+disY, pixelSize/3, pixelSize/3 );
			}
			 
		}
	}
};

drawLayer := procedure(mNetwork, r, activeNeuron) {
	gfx_setPenColor("BLACK");
	for(i in {1 .. #mNetwork}) {	
		for(j in {0 .. mNetwork[i]-1}) {
			if(activeNeuron == j && i ==1) {
				gfx_setPenColorRGB( 1.0, 0.0, 0.0 );				
				gfx_filledCircle((28*12+300*i), ((940-r*(3*mNetwork[i]-1))/2)+3*r*j, r);
			} else {
				gfx_setPenColorRGB( 0.0, 0.0, 0.0 );
				gfx_filledCircle((28*12+300*i), ((940-r*(3*mNetwork[i]-1))/2)+3*r*j, r);
				
				if(i == #mNetwork) {			
					gfx_textRight((28*12+300*i)+30, ((940-r*(3*mNetwork[i]-1))/2)+3*r*j, j);
				}
			}
		}		
	}
};	

drawConnection := procedure(mNetwork, r) {
	gfx_setPenColor("BLACK");
	for(i in {1 .. #mNetwork-1}) {	
		for(j in {0 .. mNetwork[i]-1}) {
			for(k in {0 .. mNetwork[i+1]-1}) {
				if(i<#mNetwork) {
					gfx_line((28*12+300*i+r), ((940-r*(3*mNetwork[i]-1))/2)+3*r*j, (28*12+300*(i+1)-r), ((940-r*(3*mNetwork[i+1]-1))/2)+3*r*k);
				}	
			}
		}		
	}
};

drawNetwork := procedure(mNetwork, weights) {	
	// height for mNetwork 2r*n+r*(n-1)=940
	r := 940/(3*max(mNetwork)-1);
	
	drawLayer(mNetwork, r, -1);	    	
	drawConnection(mNetwork, r);	 
	drawNeuron([], weights, false, false, 0, (940-(28*12))/2, 0, 0, 1, 0, 12);
};

animate := procedure( mNetwork, input, weights, biases, test_data ) {	
	if(input == 0) {
		gfx_clear();		
		drawNetwork(mNetwork, weights);
	} else if(input == 123) {
		gfx_clear();
		
		disX := 0;
		disY := 0;
		for(a in {1 .. 3}) {
			drawNeuron(test_data, weights, true, false, 0, 0, 0, 0, a, 1, 6);
			disY += 10;
		}
		
		disX := 0;
		disY := 0;
		for(a in {1 .. 5}) {
			disX := 0;
			for(b in {1 .. 6}) { 
				drawNeuron(test_data, weights, false, true, 100, 0, disX+b*28*6, disY, 1, 30-(a*6)+b, 6);
				disX += 10;
			}
			disY += 10+28*6;
		}
	} else if(input == 101 || input == 102 || input == 103) {
		gfx_clear();
		
		data := [];
		for(a in {1 .. 30}) {
			data +=  la_hadamard( la_matrix(weights[1][a])!, la_matrix([test_data[input-100][1]]) ) ;	
		}
		// Get calculated outputs
		[captionsHiddenLayer, outputHiddenLayer] := getCaptionForNeurons(test_data[input-100][1], weights, biases, test_data[input-100][2]);
		outputLastLayer := getNetworkOutputs(outputHiddenLayer, weights, biases);
		
		// draw output layer
		r := 940/(3*max(mNetwork)-1);
		// output values as list
		drawOutputLayer(mNetwork, 1450, 0, r, outputLastLayer);
		
		// draw input values	
		disX := 0;
		disY := 0;
		drawNeuron(test_data, weights, true, false, 0, (940-6*28)/2, disX, disY, input-100, 1, 6);
		//for(a in {1 .. 3}) {
		//	drawNeuron(test_data, weights, true, false, 0, (940-6*28)/2, 0, disY, a, 1, 6);
		//	disY += 10;
		//}
		
		disX := 0;
		disY := 0;

		// Counter for current neuron
		neuronNumber := 1;
		for(a in {1 .. 5}) {
			disX := 0;
			for(b in {1 .. 6}) {
				gfx_setPenColor("BLACK");
				gfx_textLeft(100+disX+b*28*6, disY, captionsHiddenLayer[neuronNumber]);
				disY += 10;
				drawNeuron([data], weights, true, true, 100, 0, disX+b*28*6, disY, 1, 30-(a*6)+b, 6);
				disX += 10;
				disY -= 10;
				neuronNumber += 1;
			}
			disY += 30+28*6;
		}
	} else if(mNetwork[1] < input || 1 > input) {
		gfx_setMessage( "Error: Neuron is not in Layer!" ); 
	} else {
		gfx_clear();
		gfx_setMessage( "Success: Printing neuron!" );
		r := 940/(3*max(mNetwork)-1);
		drawLayer(mNetwork, r, input-1);
		drawConnection(mNetwork, r);
		
		drawNeuron(test_data, weights, false, true, 0, (940-(28*12))/2, 0, 0, 1, input, 12);
	}	
	
	animate( mNetwork, readInput(), weights, biases, test_data );	
};

waitForStart := procedure(){
    while( gfx_isPaused() ){
        sleep(1000);
    }
};

readInput := procedure() {
	gfx_setPaused(true);
	waitForStart();
	input := rational( gfx_getInput() );
	while( input == om ){
		gfx_setMessage("Wrong input!");
        gfx_setPaused(true);
        waitForStart();
        input := rational( gfx_getInput() );
	}
	return input;
};

// i: input values (pixels)
// w: weights, b: biases
// o: output neuron (int in {0..9})
getCaptionForNeurons := procedure(i, w, b, o) {
	// Calculate output of each sigmoid neuron in second layer
	i := la_vector(i);
	a := sigmoid( (w[1]*i) + b[1] );

	// Get weights of 'selected' neuron of last layer
	ow := w[2][o];

	// Concat strings --> Captions for hidden layer
	// Form: Output * Weight of 'selected' Output Neuron
	captions := [ shortenDecimalNumber(a[k]) +  "*" + shortenDecimalNumber(ow[k]) + "=" + shortenDecimalNumber(a[k]*ow[k]) : k in [1..30] ];
	// Save outputs
	outputValues := [ a[k] : k in [1..30] ];
	return [captions, outputValues];
};
// Sigmoid function for vectors
// 1.0/(1.0+exp(-z))
sigmoid := procedure(z) {
	// z is a vector, so the function has to be used on every part of it
	return la_vector([ 1.0/(1.0 + exp(- z[i] )) : i in [1..#z] ]);
};
shortenDecimalNumber := procedure(d) {
	s := "";
	s += d;

	// For extrem small numbers which contain 'E-x'
	e_values := split(s, "E");
	if(#e_values > 1) {
		return e_values[1][1..3] + "e" + e_values[2];
	}
	else {
		return s[1..5];
	}
};

// i: input values from hidden layer
// w: weights, b: biases
getNetworkOutputs := procedure(i, w, b) {
	// Calculate output of each sigmoid neuron in second layer
	i := la_vector(i);
	a := sigmoid( (w[2]*i) + b[2] );
	return [ shortenDecimalNumber(a[k]) : k in [1..#a] ];
};

// structure is a list of nodes per layer, e.g. [784, 30, 10]
start_animation := procedure(weights, biases, structure, test_data) {
	gfx_setCanvasSize(1600, 940);
	gfx_setXscale(0, 1600);
    gfx_setYscale(0, 940);
	gfx_clear();	
	gfx_setPaused(true);
	gfx_setMessage( "Please enter the number of the neuron!" );
	gfx_addInputField( "Neuron" );
	gfx_addPlayPauseButton(true);
	
	mNetwork := structure[2..];
	drawNetwork(mNetwork, weights);
	animate( mNetwork, readInput(), weights, biases, test_data );
};